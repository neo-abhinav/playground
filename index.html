<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hand-Controlled Particle Playground</title>
    
    <!-- Load Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- Load MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        :root {
            --primary: #00f2ff;
            --bg-panel: rgba(20, 20, 30, 0.7);
            --text-color: #ffffff;
            --font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: var(--font-family);
            color: var(--text-color);
            user-select: none;
        }

        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        /* Video element for processing (hidden) */
        .input_video {
            display: none;
        }

        /* Minimal UI Overlay */
        #ui-container {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 300px;
            z-index: 10;
            background: var(--bg-panel);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 16px;
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: transform 0.3s ease, opacity 0.3s ease;
        }

        .ui-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        h1 {
            font-size: 16px;
            margin: 0;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            background-color: #ff4444; /* Red for off, Green for on */
            border-radius: 50%;
            box-shadow: 0 0 5px currentColor;
        }

        .control-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            font-size: 12px;
            margin-bottom: 5px;
            opacity: 0.8;
        }

        /* Custom Range Slider */
        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 14px;
            width: 14px;
            border-radius: 50%;
            background: var(--primary);
            cursor: pointer;
            margin-top: -5px;
            box-shadow: 0 0 10px var(--primary);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: rgba(255,255,255,0.2);
            border-radius: 2px;
        }

        /* Shape Selectors */
        .shape-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 5px;
            margin-top: 5px;
        }
        
        .shape-btn {
            background: rgba(255,255,255,0.1);
            border: none;
            border-radius: 8px;
            padding: 8px 0;
            color: white;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 18px;
        }
        
        .shape-btn:hover, .shape-btn.active {
            background: var(--primary);
            color: #000;
        }

        /* Toggles */
        .toggle-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .btn-action {
            width: 100%;
            padding: 10px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.1);
            color: white;
            border-radius: 8px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.2s;
        }
        .btn-action:hover {
            background: rgba(255,255,255,0.2);
        }

        /* Loading / Instructions overlay */
        #loading-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 5;
            pointer-events: none;
            background: rgba(0,0,0,0.6);
            padding: 20px;
            border-radius: 12px;
        }

        .key-instruction {
            margin-top: 10px;
            font-size: 12px;
            opacity: 0.7;
        }

        /* Mobile Adjustments */
        @media (max-width: 600px) {
            #ui-container {
                width: calc(100% - 40px);
                bottom: 20px;
                top: auto;
            }
        }
    </style>
</head>
<body>

    <!-- Camera Source -->
    <video class="input_video"></video>

    <!-- Canvas -->
    <div id="canvas-container"></div>

    <!-- UI Panel -->
    <div id="ui-container">
        <div class="ui-header">
            <h1>Particle Lab</h1>
            <div id="cam-status" class="status-dot" title="Camera Status"></div>
        </div>

        <div class="control-group">
            <label>Shape Template</label>
            <div class="shape-grid">
                <button class="shape-btn active" data-shape="sphere" title="Sphere">‚óè</button>
                <button class="shape-btn" data-shape="heart" title="Heart">‚ô•</button>
                <button class="shape-btn" data-shape="flower" title="Flower">‚úø</button>
                <button class="shape-btn" data-shape="saturn" title="Saturn">ü™ê</button>
                <button class="shape-btn" data-shape="buddha" title="Buddha">üßò</button>
            </div>
        </div>

        <div class="control-group">
            <label>Color</label>
            <input type="color" id="color-picker" value="#00f2ff" style="width:100%; border:none; height:30px; border-radius:4px; cursor:pointer;">
        </div>

        <div class="control-group">
            <label>Particle Count (<span id="count-val">10k</span>)</label>
            <input type="range" id="particle-count" min="2000" max="30000" step="1000" value="10000">
        </div>

        <div class="control-group">
            <label>Motion Noise</label>
            <input type="range" id="noise-strength" min="0" max="2" step="0.1" value="0.5">
        </div>

        <div class="toggle-row">
            <label style="margin:0">Camera Control</label>
            <input type="checkbox" id="camera-toggle" checked>
        </div>

        <button class="btn-action" id="screenshot-btn">üì∏ Capture Snapshot</button>
        
        <div class="key-instruction">
            <strong>Gestures:</strong> Open hands to expand. Close fists to contract. Move hands apart for zoom.<br>
            <strong>Fallback:</strong> Use Mouse Move (Horizontal) to expand/contract.
        </div>
    </div>

    <div id="loading-overlay">
        <h2>Loading Hand Tracking...</h2>
        <p>Please allow camera access.</p>
    </div>

    <script>
        /**
         * CONFIGURATION & STATE
         */
        const config = {
            particleCount: 10000,
            baseColor: new THREE.Color('#00f2ff'),
            particleSize: 0.15,
            noiseStrength: 0.5,
            useCamera: true,
            currentShape: 'sphere'
        };

        const state = {
            handOpenness: 0, // 0 (fist) to 1 (open)
            handDistance: 0.5, // Distance between hands
            isTracking: false,
            mouse: { x: 0, y: 0 },
            targetPositions: null, // Float32Array of target positions
            time: 0
        };

        // DOM Elements
        const uiElements = {
            camStatus: document.getElementById('cam-status'),
            loading: document.getElementById('loading-overlay'),
            video: document.querySelector('.input_video')
        };

        /**
         * THREE.JS SETUP
         */
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.02);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 15;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        /**
         * PARTICLE SYSTEM (SHADER & GEOMETRY)
         */
        
        // Vertex Shader: Handles position, noise, and size based on depth
        const vertexShader = `
            uniform float uTime;
            uniform float uSize;
            uniform float uExpansion;
            uniform float uNoiseStrength;
            
            attribute float aScale;
            attribute vec3 aRandom;
            
            varying vec3 vColor;
            
            // Simplex Noise (Simplified)
            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
            vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
            
            float snoise(vec3 v) {
                const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
                const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);
                vec3 i  = floor(v + dot(v, C.yyy) );
                vec3 x0 = v - i + dot(i, C.xxx) ;
                vec3 g = step(x0.yzx, x0.xyz);
                vec3 l = 1.0 - g;
                vec3 i1 = min( g.xyz, l.zxy );
                vec3 i2 = max( g.xyz, l.zxy );
                vec3 x1 = x0 - i1 + C.xxx;
                vec3 x2 = x0 - i2 + C.yyy;
                vec3 x3 = x0 - D.yyy;
                i = mod289(i); 
                vec4 p = permute( permute( permute( 
                            i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
                        + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) 
                        + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
                float n_ = 0.142857142857;
                vec3  ns = n_ * D.wyz - D.xzx;
                vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
                vec4 x_ = floor(j * ns.z);
                vec4 y_ = floor(j - 7.0 * x_ );
                vec4 x = x_ *ns.x + ns.yyyy;
                vec4 y = y_ *ns.x + ns.yyyy;
                vec4 h = 1.0 - abs(x) - abs(y);
                vec4 b0 = vec4( x.xy, y.xy );
                vec4 b1 = vec4( x.zw, y.zw );
                vec4 s0 = floor(b0)*2.0 + 1.0;
                vec4 s1 = floor(b1)*2.0 + 1.0;
                vec4 sh = -step(h, vec4(0.0));
                vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
                vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
                vec3 p0 = vec3(a0.xy,h.x);
                vec3 p1 = vec3(a0.zw,h.y);
                vec3 p2 = vec3(a1.xy,h.z);
                vec3 p3 = vec3(a1.zw,h.w);
                vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
                p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
                vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                m = m * m;
                return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );
            }

            void main() {
                // Base position
                vec3 pos = position;
                
                // Add noise based on time and random attribute
                float noiseVal = snoise(pos * 0.5 + uTime * 0.5);
                
                // Expansion effect (Hands open/close)
                // If expansion > 0, particles push out. If < 0, they suck in.
                vec3 dir = normalize(pos);
                pos += dir * (uExpansion * 5.0);
                
                // Noise displacement
                pos += dir * noiseVal * uNoiseStrength;

                vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                gl_Position = projectionMatrix * mvPosition;

                // Size attenuation
                gl_PointSize = uSize * aScale * (300.0 / -mvPosition.z);
            }
        `;

        // Fragment Shader: Soft circle + Color
        const fragmentShader = `
            uniform vec3 uColor;
            void main() {
                // Circular particle
                vec2 coord = gl_PointCoord - vec2(0.5);
                float dist = length(coord);
                if (dist > 0.5) discard;
                
                // Soft edge
                float alpha = 1.0 - smoothstep(0.4, 0.5, dist);
                
                gl_FragColor = vec4(uColor, alpha);
            }
        `;

        // Geometry Setup
        let geometry, material, points;
        
        function initParticles(count) {
            if (points) scene.remove(points);
            
            geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(count * 3);
            const randoms = new Float32Array(count * 3);
            const scales = new Float32Array(count);
            
            // Initialize with sphere shape
            const r = 5;
            for (let i = 0; i < count; i++) {
                // Sphere distribution
                const u = Math.random();
                const v = Math.random();
                const theta = 2 * Math.PI * u;
                const phi = Math.acos(2 * v - 1);
                
                const x = r * Math.sin(phi) * Math.cos(theta);
                const y = r * Math.sin(phi) * Math.sin(theta);
                const z = r * Math.cos(phi);
                
                positions[i*3] = x;
                positions[i*3+1] = y;
                positions[i*3+2] = z;

                randoms[i*3] = Math.random();
                randoms[i*3+1] = Math.random();
                randoms[i*3+2] = Math.random();
                
                scales[i] = Math.random() * 0.5 + 0.5;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('aRandom', new THREE.BufferAttribute(randoms, 3));
            geometry.setAttribute('aScale', new THREE.BufferAttribute(scales, 1));
            
            // We keep a separate CPU array for the "Target" shape positions
            state.targetPositions = new Float32Array(positions);

            material = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uColor: { value: config.baseColor },
                    uSize: { value: config.particleSize * 20 }, // scale up for shader
                    uExpansion: { value: 0 },
                    uNoiseStrength: { value: config.noiseStrength }
                },
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            points = new THREE.Points(geometry, material);
            scene.add(points);
            
            // Generate the initial shape target
            generateShapeData(config.currentShape);
        }

        /**
         * SHAPE GENERATORS (Math Patterns)
         */
        function generateShapeData(shapeType) {
            config.currentShape = shapeType;
            const count = config.particleCount;
            const arr = new Float32Array(count * 3);
            
            // Helper: Random point in sphere
            const randSphere = (rad) => {
                const u = Math.random();
                const v = Math.random();
                const theta = 2 * Math.PI * u;
                const phi = Math.acos(2 * v - 1);
                const r = rad * Math.cbrt(Math.random()); // distribute inside volume
                return {
                    x: r * Math.sin(phi) * Math.cos(theta),
                    y: r * Math.sin(phi) * Math.sin(theta),
                    z: r * Math.cos(phi)
                };
            };

            for (let i = 0; i < count; i++) {
                let x, y, z;
                const idx = i * 3;

                if (shapeType === 'sphere' || shapeType === 'fireworks') {
                    const p = randSphere(5);
                    x=p.x; y=p.y; z=p.z;
                } 
                else if (shapeType === 'heart') {
                    // Parametric Heart
                    // x = 16sin^3(t)
                    // y = 13cos(t) - 5cos(2t) - 2cos(3t) - cos(4t)
                    const t = Math.random() * Math.PI * 2;
                    // Spread indices to fill volume roughly or lines
                    // Let's add randomness for volume
                    const scale = 0.3;
                    const r = 16 * Math.pow(Math.sin(t), 3);
                    x = scale * r;
                    y = scale * (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));
                    z = (Math.random() - 0.5) * 2; // Thickness
                    
                    // Normalize and center slightly
                    y += 1; 
                } 
                else if (shapeType === 'flower') {
                    // Phyllotaxis (Sunflower)
                    const spread = 0.1;
                    const angle = i * 137.5 * (Math.PI / 180);
                    const r = spread * Math.sqrt(i);
                    x = r * Math.cos(angle);
                    y = r * Math.sin(angle);
                    z = (Math.random() - 0.5) * (1 - r/8) * 2; // Taper thickness at edges
                    // Make it look like a cup/flower
                    z += r*r * 0.05;
                    
                    // Rotate to face camera
                    const tempY = y; 
                    y = z - 2; 
                    z = tempY;
                }
                else if (shapeType === 'saturn') {
                    // Planet + Ring
                    if (i < count * 0.4) {
                        // Planet
                        const p = randSphere(2.5);
                        x=p.x; y=p.y; z=p.z;
                    } else {
                        // Ring
                        const angle = Math.random() * Math.PI * 2;
                        const dist = 3.5 + Math.random() * 2.5;
                        x = dist * Math.cos(angle);
                        z = dist * Math.sin(angle);
                        y = (Math.random() - 0.5) * 0.2;
                        
                        // Tilt
                        const tilt = 0.4;
                        const tx = x;
                        const ty = y * Math.cos(tilt) - z * Math.sin(tilt);
                        const tz = y * Math.sin(tilt) + z * Math.cos(tilt);
                        x=tx; y=ty; z=tz;
                    }
                }
                else if (shapeType === 'buddha') {
                     // Abstract Meditating Figure (Stacked spheres approach)
                     const part = Math.random();
                     let p;
                     if (part < 0.2) { 
                         // Head
                         p = randSphere(1.2);
                         y = p.y + 3.5; x = p.x; z = p.z;
                     } else if (part < 0.6) {
                         // Body
                         p = randSphere(2.0);
                         // Scale y to make oval
                         y = p.y * 1.4; x = p.x * 1.2; z = p.z;
                     } else {
                         // Legs / Base
                         const angle = Math.random() * Math.PI * 2; // full circle for lotus
                         const rad = 2.0 + Math.random() * 1.5;
                         x = rad * Math.cos(angle);
                         z = rad * Math.sin(angle);
                         y = (Math.random() - 0.5) * 1.5 - 2.5;
                     }
                }

                arr[idx] = x;
                arr[idx+1] = y;
                arr[idx+2] = z;
            }
            
            state.targetPositions = arr;
        }

        /**
         * HAND TRACKING LOGIC
         */
        
        function onResults(results) {
            uiElements.loading.style.display = 'none';
            uiElements.camStatus.style.backgroundColor = '#00ff00'; // Green
            state.isTracking = true;

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                
                // 1. Calculate Openness (Average dist of tips from wrist)
                const wrist = landmarks[0];
                const tips = [8, 12, 16, 20].map(i => landmarks[i]);
                
                let avgDist = 0;
                tips.forEach(tip => {
                    const dx = tip.x - wrist.x;
                    const dy = tip.y - wrist.y;
                    avgDist += Math.sqrt(dx*dx + dy*dy);
                });
                avgDist /= 4;
                
                // Map avgDist: roughly 0.1 (closed) to 0.4 (open) -> 0 to 1
                const openness = Math.max(0, Math.min(1, (avgDist - 0.15) * 4));
                state.handOpenness = lerp(state.handOpenness, openness, 0.2); // Smooth it

                // 2. Calculate Distance between hands (if 2 hands detected)
                if (results.multiHandLandmarks.length > 1) {
                    const l1 = results.multiHandLandmarks[0][0]; // Wrist 1
                    const l2 = results.multiHandLandmarks[1][0]; // Wrist 2
                    const dx = l1.x - l2.x;
                    const dy = l1.y - l2.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    state.handDistance = lerp(state.handDistance, dist, 0.1);
                }
            } else {
                // No hand detected, slowly reset
                state.handOpenness = lerp(state.handOpenness, 0.5, 0.05);
            }
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        // Camera setup
        const videoElement = uiElements.video;
        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                if (config.useCamera) await hands.send({image: videoElement});
            },
            width: 640,
            height: 480
        });
        
        // Start Camera
        cameraUtils.start().catch(e => {
            console.error(e);
            uiElements.loading.innerHTML = "<p>Camera denied/unavailable.<br>Using Mouse Fallback.</p>";
            setTimeout(() => uiElements.loading.style.display = 'none', 2000);
        });

        /**
         * ANIMATION LOOP
         */
        
        function lerp(start, end, amt) {
            return (1 - amt) * start + amt * end;
        }

        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            state.time += delta;

            if (material) {
                // 1. Update Uniforms
                material.uniforms.uTime.value = state.time;
                material.uniforms.uNoiseStrength.value = config.noiseStrength;
                
                // 2. Calculate Interaction Values
                let expansionVal, scaleVal;
                
                if (config.useCamera && state.isTracking) {
                    // Map Hand Openness (0 to 1) to Expansion (-1 to 1)
                    // Open hand (1) -> Spread (1). Closed (0) -> Contract (-1)
                    expansionVal = (state.handOpenness - 0.5) * 2.0; 
                    
                    // Map Hand Distance to Global Scale (Zoom)
                    scaleVal = 0.5 + state.handDistance * 2.0; 
                } else {
                    // Mouse Fallback
                    // Map mouse X (-1 to 1) to Expansion
                    expansionVal = state.mouse.x;
                    scaleVal = 1.0;
                }

                // Smoothly interpolate shader uniforms
                material.uniforms.uExpansion.value = lerp(material.uniforms.uExpansion.value, expansionVal, 0.1);
                
                // Adjust camera Z for scale/zoom effect
                const targetZ = 15 + (1 - scaleVal) * 5;
                camera.position.z = lerp(camera.position.z, targetZ, 0.05);

                // 3. Morphing Logic (CPU Lerp to GPU buffer)
                // This gives the "swarming" effect moving to new shapes
                const positions = geometry.attributes.position.array;
                const targets = state.targetPositions;
                
                let needsUpdate = false;
                
                // Optimization: Only update if not practically identical or if shape just changed
                // For this demo, we run continuously for fluid attraction effect
                for (let i = 0; i < config.particleCount; i++) {
                    const idx = i * 3;
                    // Move current pos towards target pos
                    // Speed depends on "viscosity" or randomness
                    const speed = 0.05; // + (Math.random() * 0.02);
                    
                    positions[idx] += (targets[idx] - positions[idx]) * speed;
                    positions[idx+1] += (targets[idx+1] - positions[idx+1]) * speed;
                    positions[idx+2] += (targets[idx+2] - positions[idx+2]) * speed;
                }
                
                geometry.attributes.position.needsUpdate = true;
                
                // Rotate whole system slightly
                points.rotation.y += 0.002;
            }

            renderer.render(scene, camera);
        }

        /**
         * UI & EVENTS
         */
        
        // Init
        initParticles(config.particleCount);
        animate();
        
        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Mouse Move Fallback
        document.addEventListener('mousemove', (e) => {
            if (!config.useCamera) {
                state.mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                state.mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            }
        });

        // Toggle Camera
        document.getElementById('camera-toggle').addEventListener('change', (e) => {
            config.useCamera = e.target.checked;
            if (!config.useCamera) {
                uiElements.camStatus.style.backgroundColor = '#ff4444'; // Red
            } else if (state.isTracking) {
                uiElements.camStatus.style.backgroundColor = '#00ff00';
            }
        });

        // Shape Selection
        document.querySelectorAll('.shape-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                document.querySelectorAll('.shape-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                generateShapeData(btn.dataset.shape);
            });
        });

        // Particle Count
        const countSlider = document.getElementById('particle-count');
        countSlider.addEventListener('input', (e) => {
            config.particleCount = parseInt(e.target.value);
            document.getElementById('count-val').innerText = (config.particleCount / 1000) + 'k';
            initParticles(config.particleCount); // Re-init needed
        });

        // Color
        document.getElementById('color-picker').addEventListener('input', (e) => {
            config.baseColor = new THREE.Color(e.target.value);
            if(material) material.uniforms.uColor.value = config.baseColor;
        });

        // Noise
        document.getElementById('noise-strength').addEventListener('input', (e) => {
            config.noiseStrength = parseFloat(e.target.value);
        });

        // Screenshot
        document.getElementById('screenshot-btn').addEventListener('click', () => {
            renderer.render(scene, camera);
            const dataURL = renderer.domElement.toDataURL('image/png');
            const link = document.createElement('a');
            link.download = 'particles_' + Date.now() + '.png';
            link.href = dataURL;
            link.click();
        });

    </script>
</body>
</html>